何をするスクリプト？

対象の RectTransform（例：PlayerRoot/EnemyRoot） が、指定した container（例：PlayAreaFrame） の内側に収まるよう、毎フレーム位置を押し戻してくれます。

アンカー／ピボットの設定に依存せずに効くよう、四隅のワールド座標で境界判定します。

M5移動や敵の自動移動より**後に走る（LateUpdate）**ため、「動かした→はみ出しそう→押し戻す」の順で安定します。

どうやって動いているの？

四隅の取得（ワールド座標）

container.GetWorldCorners(...) と rect.GetWorldCorners(...) で、外枠と対象の四隅をワールド座標で取得します。

ここから cMinX/cMaxX/cMinY/cMaxY と tMinX/tMaxX/tMinY/tMaxY を求めます。

内側の境界を決定

container の境界に padding（px） を内側へ差し引いて「進入禁止ライン」を作ります。

例：cMinY = container下端 + padding.y

必要な補正量（dx, dy）を計算

対象が container より小さいとき：

下にはみ出していれば dy = cMinY - tMinY（上に押し戻す）

上にはみ出していれば dy = cMaxY - tMaxY（下に押し戻す）

横も同様に dx を計算

対象が container より大きいとき：

端を揃えられないので、中心を合わせる（見切れるが、失われる量が最小で安定）

ワールド→親ローカルへ変換して適用

計算した dxW/dyW はワールド空間の補正なので、
親 RectTransform に対して InverseTransformVector でローカル（anchoredPosition相当）の差分に変換し、
rect.anchoredPosition += localDelta; として安全に適用します。

これにより回転やスケールの影響を受けにくく、上下の片側だけ止まらない…といったズレを防ぎます。

Inspector の主な項目

Container（RectTransform）
クランプの外枠。通常は PlayAreaFrame を割り当てます（必須）。

Padding（Vector2）
枠の内側にどれだけ余白を残すか（px）。(8, 8) など小さめから調整。

Debug（任意）

drawGizmos：選択中に**緑（container）／黄（対象）**の枠を Scene ビューに表示。

debugLog：境界値と補正量をログ出力（挙動が怪しい時の診断用）。

正しく効かせるコツ

対象 = “実際に移動している” RectTransform 本体に付ける
例：PlayerMoverFromM5 を PlayerRoot に付けているなら、UIRectClamp も PlayerRoot に付ける。

Container は PlayAreaFrame
HUDCanvas や SplitRoot を入れると基準がズレます。

親チェーンの変形を素直に
Canvas → SplitRoot → PlayAreaFrame → PlayerRoot の各 Transform は
Rotation = (0,0,0)、Scale = (1,1,1) を基本に。変形が入ると境界も回転・拡縮されます。

Layout 系の干渉に注意
PlayAreaFrame に Layout Group があるのはOKですが、Player/Enemy 本体に
ContentSizeFitter や LayoutElement で位置が拘束されると移動・補正が効きにくくなります。

動作確認のやり方（上下が不安な時）

Scene ビュー右上の Gizmos を ON。

PlayerRoot（または EnemyRoot）を選択すると、

緑：PlayAreaFrame の内側境界（padding 反映後）

黄：対象オブジェクトの当たり矩形
が表示されます。

再生して傾ける／動かす → 黄枠が緑枠に触れたらそれ以上出ずに押し戻ることを確認。
途中で止まる／はみ出す場合は、上の「コツ」を再点検し、padding を適量に。

どこで使う？

PlayerRoot / EnemyRoot の両方に付け、Container=PlayAreaFrame を指定しておけば、
どんな移動（M5・蛇行・ウェイポイント）でも最後に枠内へ収める“ガードレール”として働きます。

タグや Layer に依存しないため、当たり判定の設計と無関係に安全に使えます。


1) using（定型文）
using UnityEngine;

2) クラス宣言
[RequireComponent(typeof(RectTransform))]
public class UIRectClamp : MonoBehaviour
{


UI要素を動かす前提なので、RectTransform が必須。

3) インスペクター設定項目
    [Header("制限設定")]
    [Tooltip("この枠の中に対象を収める")]
    [SerializeField] private RectTransform clampArea;


clampArea は制限枠。
プレイヤーや敵はこの中に閉じ込められる。
例：PlayAreaFrame（左のゲームエリアのRectTransform）を指定する。

4) 内部変数
    private RectTransform self;


自分自身の RectTransform を保持する。

5) 初期化
    void Awake()
    {
        self = GetComponent<RectTransform>();
    }

6) 毎フレーム、範囲内にClampする処理
    void LateUpdate()
    {
        if (!clampArea || !self) return;

        // 枠の座標系に変換
        Vector2 pos = self.anchoredPosition;
        Vector2 halfSize = self.rect.size * 0.5f;
        Vector2 areaHalf = clampArea.rect.size * 0.5f;

        // X座標をClamp
        pos.x = Mathf.Clamp(pos.x,
            -areaHalf.x + halfSize.x,
            areaHalf.x - halfSize.x);

        // Y座標をClamp
        pos.y = Mathf.Clamp(pos.y,
            -areaHalf.y + halfSize.y,
            areaHalf.y - halfSize.y);

        self.anchoredPosition = pos;
    }

7) 完成コード全体
using UnityEngine;

[RequireComponent(typeof(RectTransform))]
public class UIRectClamp : MonoBehaviour
{
    [Header("制限設定")]
    [Tooltip("この枠の中に対象を収める")]
    [SerializeField] private RectTransform clampArea;

    private RectTransform self;

    void Awake()
    {
        self = GetComponent<RectTransform>();
    }

    void LateUpdate()
    {
        if (!clampArea || !self) return;

        Vector2 pos = self.anchoredPosition;
        Vector2 halfSize = self.rect.size * 0.5f;
        Vector2 areaHalf = clampArea.rect.size * 0.5f;

        pos.x = Mathf.Clamp(pos.x,
            -areaHalf.x + halfSize.x,
            areaHalf.x - halfSize.x);

        pos.y = Mathf.Clamp(pos.y,
            -areaHalf.y + halfSize.y,
            areaHalf.y - halfSize.y);

        self.anchoredPosition = pos;
    }
}

8) 使い方

プレイヤーまたは敵の GameObject にこのスクリプトをアタッチする。

Clamp Area に PlayAreaFrame（ゲームエリアの枠）を指定する。

再生すると、対象が範囲外に出ようとしても端で止まる。